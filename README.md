文章简介：
1. 文章标题：NED:An Inter-Graph Node Metric Based on Edit Distance
1. [文章来源](https://arxiv.org/pdf/1602.02358.pdf)：[VLDB 2017](http://zhuhaohan.com/Research/NED/p573-zhu.pdf)
2. 作者：
2.1.  [朱浩瀚](http://zhuhaohan.com)（苹果公司）、
2.2.  Xianrui Meng(Apple Inc)
2.3.  George Killoos(Boston University)
3.[Git项目地址](https://github.com/zhuhaohan/NED)

@[TOC]
# NED:An Inter-Graph Node Metric Based on Edit Distance
# 摘要：
          
   > &emsp;&emsp;节点的相似性的研究是图论中的重要问题。以往科研人员总是把重心放在图的内部的节点的相似性中，对于图与图之间的相似性的研究还不够。况且人们经常在社会网络、自传等方面用到这样的相似性的比较，因此对于图间结点相似性的研究是十分必要的。
      &emsp;&emsp;作者提出了一种NED的方法，它是基于TED*的方法上面经过改造的一种具有度量 性质的函数。它可以通过构建一个结点的邻居拓扑结构来比较结点之间的相似性，并且不管这个图是否有标签的信息都可以比较图中的某个结点。
      &emsp;&emsp;NED作为一种度量标准，可以提供**==有效的索引==**（？），同时在这篇文章中，作者通过一个去匿名化的例子来表明了NED相比于Feature的方法更加高效。


 （在正式介绍本文时，我们先来介绍一些基础知识以方便读者的理解）
   1.  NP-Complete
   2. 去匿名化（OddBall/NetSmile/ReFX/HITS）
    3. Ego-Network
      4. 多项式可计算
      5. 广度优先搜索
      6. 子树的概念
      7. 图的同构
      8. 生成树
      9. 树的同构
      10. 集合差的运算
      11. 完全二部图概念
      12. 映射的概念（什么是双射）
      13. 匈牙利算法是什么
      14. 子图的含义是什么
      15. ReFx
      16. HITS是什么
      17. A*是什么算法
      18. 什么是训练集，什么是测试集


&emsp;&emsp;社会网络中结点相似度问题是图论中的一个重要问题。但是最近几年来的研究一直把重心放在了一个图中的节点相似度的研究中，图和图之间的节点相似度的研究还没有得到广泛的关注。但是，图间节点相似度的研究对于转移学习是十分重要的。如给定一个已知信息的图，从这个图中提取信息从而推断出另外一个图的信息都要用到图间节点的相似度。图间节点相似度的研究将会应用在生物、交流和网络的领域。
&emsp;&emsp;我在阅读了VLDB 2017的论文[1]和SIGKDD 2002[2]之后以及近期的其他论文，写下了本篇报告。报告中将结合俩位作者的成果，展开详细的叙述。
&emsp;&emsp;本文作者在前人的研究中提出了一种叫做NED（基于编辑距离的图间节点的相似度）的算法，此算法的目的是为了测度图间节点的相似度。在NED中，俩个节点根据他们邻居拓扑结构的信息进行比较，这里的邻居拓扑结构指的是新定义的k-adjacent树。由于比较图的编辑距离是NP问题，所以NED的比较久显得有优势了，比如NED是多项式时间内可计算的方法。同时NED相比于其他的方法，不仅仅有测度性质，同时还有比较高的效率。

&emsp;&emsp;本文对于图间节点的相似度的研究，主要研究成果及 贡献如下：
1. 作者人提出了一种多项式时间内可计算的函数NED，它可以用来测度图间节点的相似度。
2. 作者提出了一种修改后的编辑距离TED*,用来比较无序树，同时TED*也是多项式时间内可计算的。
3. 将TED*和原来的TED进行比较，体现出优化的性能。
4.由于NED的测度性能，TED可以高效地找出图中相似的节点。

关键字：社会网络；结点相似度；图的相似度；树
 
## 第二章 节点的邻居拓扑结构的选择
### 2.1 K-adjacent树
### 定义1：
&emsp;&emsp;给定一个图G，若存在其中的某个顶点v,则其中的顶点V的k-adjacent树就是以v为树根，经过宽度优先遍历的树。树的高度为k层，代表了前k层子树的高度。
### 2.2 子图同构复杂度
	
 &emsp;&emsp;由于在图论领域中，目前仍然把图的同构问题定义为NP问题，因此作者选用了树的同构作为俩个节点之间相似性比较的基准。
## 第三章 节点相似度
### 3.1 TED*
&emsp;&emsp;TED*(树的编辑距离的改进版本)，TED* 用来将一棵树转变为另外一棵树后，所需要的最少的编辑次数。转变过程中包括：
	1）插入一个结点
	2）删除一个结点
	3）同一层移动一个结点
	&emsp;&emsp;TED* 和原来的TED相比最主要的不同是：TED操作过程中不会改变节点的深度。然后结点深度在一棵树中表示了这个节点的拓扑结构，因此作者利用了TED*这个特点引入了NED的方法。具体参见图2
 
图2 TED*和TED的比较
###  3.2 NED
&emsp;&emsp;NED是基于TED*而来的，它是俩棵树之间经过TED*的编辑后，得到的值。其逻辑关系用下面等式表示：
	δ^k（u，v）=δ^k（T(u,k) , T(v，k)）
	通俗地讲，俩个图中的节点转换成的K-adjcent树的TED*的值，就是NED的值。
## 第四章 TED*的计算
&emsp;&emsp;NED的取决于TED*的值，因此作者详细提出了TED*的算法。算法分为六个步骤，节点的每一个K-adjacent树的每层，都会从下往上运行这个算法，直到根节点为止。以下是计算TED*的六个步骤。
### 4.1 节点Padding
&emsp;&emsp;Padding是根据俩个k-adjacent树的同一层的个数的差值决定的。例如俩棵树的第4层，一个有三个节点，一个有五个节点，那么Padding@Cost=2
### 4.2 节点Canolization
&emsp;&emsp;节点的Canolization是在Padding之后运行的。标签树的同构代表了俩个数具有相同的树形，但是对于从图中节点所提取的节点的k-adjacent树是没有标签的，如何进行同构的比较？那么作者提出了可以为k-adjacent树进行Canonization。具体的同构规则如下：如果俩个节点的子树是同树形的，那么这俩个节点的标签是一样的。根据规则，树中所有叶子节点因为没有子树，因此都会有相同的标签。作者把叶节点的标签赋值为0，那么对于其他的标签作者提出了一个如下的算法：
 
 &emsp;&emsp;从算法可知，每个节点的标签虽然需要将其子树进行比较，但是只需要比较其孩子节点，子孙节点不需要考虑。因为算法是自底向上运行的，每个节点已经包含了其孩子节点。算法中标签值的大小以及先后顺序都是不重要的，可以使1,2,3….也可以是A,B,C…. 下面图3是节点的Canolization的例子。
 
图三  节点的Canolization
### 4.3 完全二部图的构建
 &emsp;&emsp;在节点的Canolization之后开始进行完全二部图的构建。构建的对象是两棵树对应层节点。由于二部图的定义是把图中节点分为俩类，因此在构建过程中，每一个节点和相对应的另一层的节点有一条边，而边权重就是每个节点孩子的标签的不同个数。若节点A的孩子标签集合是{1,2,4}，节点B的孩子的标签集合是{2,3,4}，那么A和B之间的权重是2。下图是二部图构建的一个例子。
 
图4 加权完全二部图构建
&emsp;&emsp; 从图4可以清楚看出，在完全二部图构建之前，必去进行Padding以及Canolization之后才能保证有相同个数的节点进行构建。需要注意的是，为了防止计算重复的匹配成本Matching Cost，在Padding中的节点是不连接到任何一个父节点进行计算的。那么图中的权值的具体含义是什么呢？权值代表了在相同层进行移动节点所需要的次数。而最小权值的综合是评估NED的一个重要成本。
### 4.4 二部图的匹配
 &emsp;&emsp;二部图匹配是4.4所提的二部图构建中，在二部图节点一一匹配的条件下，找出其中最小权值和的计算过程。形式化语言表示如下：
f_i:m(G^2 )=Min∑_(∀x∈L_i (u))▒〖w(x,f_i (x))〗
 ### 4.5  匹配成本计算
&emsp;&emsp; 由于匹配成本表示把俩个K-adjacent树的一层转换为对应层所需要的最小操作次数，因此匹配成本的计算需涉及Padding值和4.4中的二部图匹配的最小值。形式化语言如下：
M_i=(m(G_i^2 )-P_(i+1) )/2
	如果要计算第i层的匹配成本，那么需要计算第i层的二部图构建成本和第i+1层的Padding成本。由于在匹配过程中的双射关系，第i层中的节点x匹配到对应的另外一棵树中的y，这需要产生一次匹配成本；相对应的y匹配到x又是一次匹配成本，为了不计算重复的大小，需要去匹配过程中总花费的一半。
### 4.6 节点的Re-Canolization
 &emsp;&emsp;作者基于不用给每层节点Padding的情况下，为节点Recanolization。Recanolization的规则如下：
 	 
&emsp;&emsp;总结来讲，经过双射函数匹配后的节点的标签值，需要将每层节点个数较大的那个标签赋值。赋值完之后，进行下一个节点的算法的运算。
## 第五章 算法分析
### 5.1 算法满足的可测量性质
	作为算法，NED满足一下四个性质
	①非负性
	②对称性
	③相等性
	④三角不等式性
	由于编辑操作的值最小是1，因此满足性质①；在俩个K-adjacent树中，层节点转换到相对应的层节点之间的编辑距离是相同的，因此满足性质②。
### 5.2 复杂度分析
 由于算法是自下而上逐层运行的，因此假设m、n是俩个树对应层节点的个数，并且假设m>n。
第一步：Padding 复杂度：O(m-n)
第二步：Canolization 复杂度：O（（m-n）log(m+n)）
第三步：二部图构建 复杂度：O(mn)
第四步：二部图匹配 复杂度：O($m^3$)
第五步：匹配成本计算 复杂度：O(m)
因此，总体来说整个NED算法的时间复杂度是O($Km^3$)，其中K是指k-adjacent的层数。由于在K-adjacent中的k值不需要设置太大，因此整个算法的复杂度在实际运算过程中是高效的。
## 第六章 实验
## 6.5 案例研究：去匿名化的应用
&emsp;&emsp; 所需要的知识：[置换检验](https://www.plob.org/article/3176.html)
 &emsp;&emsp;用这个案例是为了表现NED的性质。图的去匿名化是数据库和数据挖掘领域重要的隐私问题。社交网络中的用户通常会匿名化自己的一些数据，但是有一些去匿名化的技术可以通过已经公布的信息来挖掘有用的信息。以前经常用基于特征的相似度来解决去匿名化的问题。这个实验通过将PGP和DBLP中的数据分成两个部分（训练集：存放含有标识的子图，测试集：不含有标识，经过朴素化、稀疏化、扰动化的匿名子图），进行模拟去匿名化的过程。所使用的方法：在测试集集中（不含有标识的子图）通过猜测方法，找到前面最最相似的节点进行分配标识。由于NED可以通过更多的拓扑信息来进行计算，它可以更加精确（前面提过）。相反的，HITS和基于特征的方法的精确性就差些了。
	
## 补充信息：
文献来源：
>https://arxiv.org/pdf/1602.02358.pdf
>文章相关资料：https://github.com/tiankonghenlan20113046/NED

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191118214243415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NhcHR1cmVJdFRlY2hub2xvZ3k=,size_16,color_FFFFFF,t_70)

&emsp;&emsp;注意作者最后的定义，这种metric可以为图相似度服务。检查俩个图的相似度，可以通过检查俩个图中点对的相似度，如果相似的点越多，则俩个图的相似性越大。点的metric文章已经给出，可以使用这种metric去计算。
# 文章总结：

1.  文章解决的问题：比较俩个图中节点对的相似度。给定俩个图，通过修改的树的编辑距离TED*的这个metric，去计算图间节点的相似度。同时许多文献的角度大多集中在图内节点的相似度，比如SimRank及其变种的算法、ReFeX[7]、HITTS这些算法。
2. 作者使用的方法：通过修改树的编辑距离TED，提出了一种新的编辑距离TED*，这种编辑距离是在多项式时间内可以计算的，然后通过这种可以计算的修改后树的编辑距离，提出了NED这种metric。相对于NP-C的TED来讲，NED满足了metric的四种基本条件。同时metric考虑到了节点的拓扑结构（k-adjacent tree）,有效地计算了图间节点的相似度。

3. 作者创新点：
3.1 虽然也是研究了节点的相似度，但是前人的工作大多集中在了图内的节点。
3.2 从树的编辑距离考虑了节点的相似度。

4. 作者方法的不足：
4.1 全文分析了如何比较俩个图中点对的相似度，但是没有把算法放在俩个图中所有点对的计算。并且一个点对的计算复杂度在文章提到，高达$O(m^3)$(假设$m、n$是k-adjacent树的对应层节点个数)。虽然文章用了$Hungarian$算法去匹配二部图，但是指数为3对于算法来说还是很高，有没有匹配二部图的算法，可以把这个成本往下降低？
4.2 对于$k$取值的问题，文章都是通过实验取经验获得，但是$k$应该通过理论分析得出，实验的开销很大。这也是很多运用$k-adjacent$树作为索引经常存在的问题，在将索引进行应用之前，有没有理论分析可以证明出对于哪种数据集，适合什么样的$k$值呢？
4.3 文章忽略了节点和边的label。从算法开始，都没有考虑过有label节点的情况。虽然在算法的第二步进行了节点Canoliazation，但是加上标签的情况是为了确定子树是相同的树形结构。所以如果考虑到边和节点的label，应该会更准确些。即在图的算法中，考虑的结构信息越多，度量越精准。
